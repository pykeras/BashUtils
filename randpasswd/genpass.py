#!/usr/bin/env python3
import os, argparse, random, string, json

# import maskpass
from cryptography.fernet import Fernet


class PassGen:

    # def __init__(self):

    def random_password(self, plen, ext):
        base = string.ascii_letters + """1234567890!@#$%^&*?~`'":;"""
        extend = """+=-_,.|\\}{)(][/><"""
        if ext:
            return "".join(random.choices(base + extend, k=plen))
        return "".join(random.choices(base, k=plen))

    def generate_key(self, path):
        try:
            key = Fernet.generate_key()
            with open(path, "wb") as f:
                f.write(key)
            return Fernet(key)
        except:
            print("Can not save secret.key")

    def load_key(self, path):
        try:
            with open(path, "rb") as f:
                k = f.read()
            return Fernet(k)
        except:
            print("Can not read secret.key")

    def load_file(self, fpath):
        try:
            with open(fpath, "r") as f:
                return json.load(f)
        except:
            print("File {fpath} does not exists or is wrong")

    def write_file(self, fpath, data):
        try:
            with open(fpath, "w") as f:
                json.dump(data, f)
        except:
            print(
                "Something goes wrong trying to save to file (Check directory permissions)"
            )

    def read_password(self, kpath, fpath, name):
        try:
            fernet = self.load_key(kpath)
            pwdict = self.load_file(fpath)
            if name in pwdict:
                found_pass = fernet.decrypt(bytes(pwdict[name], "utf-8"))
                return str(found_pass, encoding="utf-8")
            return "No result for {name}"
        except:
            print("Something goes wrong, cannot retrieve password.")

    def init_only(self, kpath, fpath):
        self.generate_key(kpath)
        self.write_file(fpath, {})

    def write_password(self, kpath, fpath, name, plen, ext):
        try:
            raw_pass = self.random_password(plen, ext)
            if not name:
                return raw_pass
            fernet = self.load_key(kpath)
            pw = str(fernet.encrypt(raw_pass.encode("utf-8")), encoding="utf-8")
            pwdict = self.load_file(fpath)
            if name not in pwdict:
                pwdict[name] = pw
                self.write_file(fpath, pwdict)
                return raw_pass
            else:
                while True:
                    act = input(
                        "Name already exists do you wan't to overwrite it? (Y/N)"
                    )
                    if act == "Y":
                        pwdict[name] = pw
                        self.write_file(fpath, pwdict)
                        return raw_pass
                    elif act == "N":
                        return "Stopped by user request."
        except:
            print("Something goes wrong in password generation")

        # if is_init:
        #     fernet = self.generate_key(kpath)
        #     with open(fpath, "wb") as f:
        #         f.write("#Generated by genpass, don't change anything manually.")
        #     if name:
        #         key=self.load_key(kpath)
        #         with open(fpath, "wb") as f:


# print(f"\n{'='*10}Random Passwod Generator{'='*10}")
# password = maskpass.askpass(prompt="Your password: ", mask="")
# name = input("Give your password a name: ")

# name = "Email"
# base = string.ascii_letters + """1234567890!@#$%^&*?~`'":;"""
# extend = """+=-_,.|\\}{)(][/><"""
# plen = 20
# passw = "".join(random.choices(base, k=plen))
# print(f"Password for {name} is : {passw}\nSuccessfully created.")
# # option to get an specific name password
# # hash file to save password not password them self (or maybe both)
# # using a key file instead of password

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Random Password Generator")
    parser.add_argument(
        "--init",
        action="store_true",
        help="Initialize and generate encrypted file and key",
    )
    parser.add_argument(
        "-n",
        type=str,
        help="A name for new password, will help you remember and retrive password easier.",
    )
    parser.add_argument(
        "-i",
        required=False,
        default=os.path.join(os.getcwd(), "secret.key"),
        help="Path to the key (include it's name). default current dir",
    )
    parser.add_argument(
        "-f",
        required=False,
        default=os.path.join(os.getcwd(), "passgen.enc"),
        help="Path to the encrypted file (include it's name). default current dir",
    )
    parser.add_argument(
        "-l",
        required=False,
        type=int,
        default=8,
        help="length of new random password 8 or higher (default:8)",
    )
    parser.add_argument(
        "-e",
        required=False,
        action="store_true",
        help="if provided password may include +=-_,.|\/{}()[]<> characters.",
    )
    args = parser.parse_args()
    print(args)
